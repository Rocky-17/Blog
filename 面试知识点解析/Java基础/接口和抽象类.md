# 接口与抽象类  

## 接口

>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。
>——《Java核心技术（卷Ⅰ）》  

&emsp;&emsp;以Runnable接口为例：
```
@FunctionalInterface
public interface Runnable {
    /**
     * When an object implementing interface <code>Runnable</code> is used
     * to create a thread, starting the thread causes the object's
     * <code>run</code> method to be called in that separately executing
     * thread.
     * <p>
     * The general contract of the method <code>run</code> is that it may
     * take any action whatsoever.
     *
     * @see     java.lang.Thread#run()
     */
    public abstract void run();
}
```  
&emsp;&emsp;使用实现Runnable接口创建线程的方式时，每一个实现Runnable的类都必须有一个run()方法。
```
class byRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread());
    }

    public static void main(String[] arg) {
        Thread thread = new Thread(new byRunnable());
        thread.start();
    }
}
```  

### 接口的特性  

&emsp;&emsp;接口不是类，不能使用new运算符实例化一个接口。  
&emsp;&emsp;可以用instanceof检查一个对象是否实现了某个接口。
```
System.out.println(thread instanceof Runnable)  //ture
```  
&emsp;&emsp;接口里不能包含实例域或静态方法，但可以包含常量。  


## 抽象类  

## 接口与抽象类的区别  

&emsp;&emsp;接口的方法默认是public，所有⽅法在接⼝中不能有实现(Java8开始接⼝⽅法可以有默认实现），抽向类的抽象方法可以由public、protected、default修饰。  
&emsp;&emsp;接⼝中除了static 、final变量，不能有其他变量。  
&emsp;&emsp; ⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过extends关键字扩展多个接⼝。  
&emsp;&emsp;抽象类可以包含静态方法，接口内不能包含静态方法。  
&emsp;&emsp;抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static类型，并且默认为public 

## Q&A  

### 1. Java 抽象类可以有构造函数吗？
&emsp;&emsp;可以有，抽象类可以声明并定义构造函数。因为你不可以创建抽象类的实例，所以构造函数只能通过构造函数链调用（Java 中构造函数链指的是从其他构造函数调用一个构造函数），例如，当你创建具体的实现类。现在一些面试官问，如果你不能对抽象类实例化那么构造函数的作用是什么？好吧，它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。另外，即使你没有提供任何构造函数，编译器将为抽象类添加默认的无参数的构造函数，没有的话你的子类将无法编译，因为在任何构造函数中的第一条语句隐式调用 super()，Java 中默认超类的构造函数。  

### 2. Java 抽象类可以实现接口吗？它们需要实现所有的方法吗？
&emsp;&emsp;可以，抽象类可以通过使用关键字 implements 来实现接口。因为它们是抽象的，所以它们不需要实现所有的方法。好的做法是，提供一个抽象基类以及一个接口来声明类型 。这样的例子是，java.util.List 接口和相应的 java.util.AbstractList 抽象类。因为 AbstractList实现了所有的通用方法，具体的实现像 LinkedList 和 ArrayList 不受实现所有方法的负担，它们可以直接实现 List 接口。这对两方面都很好，你可以利用接口声明类型的优点和抽象类的灵活性在一个地方实现共同的行为。

### 3. Java 抽象类可以是 final 的吗？
&emsp;&emsp;不可以，Java 抽象类不能是 final 的。将它们声明为 final 的将会阻止它们被继承，而这正是使用抽象类唯一的方法。它们也是彼此相反的，关键字 abstract 强制继承类，而关键字final 阻止类被扩展。在现实世界中，抽象表示不完备性，而 final 是用来证明完整性。底线是，你不能让你的 Java 类既 abstract 又 final，同时使用，是一个编译时错误。  

### 4. Java 抽象类可以有 static 方法吗？
&emsp;&emsp;可以，抽象类可以声明并定义 static 方法，没什么阻止这样做。但是，你必须遵守 Java中将方法声明为 static 的准则。  

### 5. 可以创建抽象类的实例吗？
不可以，你不能创建 Java 抽象类的实例，它们是不完全的。即使你的抽象类不包含任何抽象方法，你也不能对它实例化。将类声明为 abstract 的，就等你你告诉编译器，它是不完全的不应该被实例化。当一段代码尝试实例化一个抽象类时 Java 编译器会抛错误。  

### 6. 抽象类必须有抽象方法吗？
&emsp;&emsp;不需要，抽象类有抽象方法不是强制性的。你只需要使用关键字 abstract 就可以将类声明为抽象类。编译器会强制所有结构的限制来适用于抽象类，例如，现在允许创建一些实例。是否在抽象类中有抽象方法是引起争论的。我的观点是，抽象类应该有抽象方法，因为这是当程序员看到那个类并做假设的第一件事。这也符合最小惊奇原则。

### 8. 何时选用抽象类而不是接口？
&emsp;&emsp;这是对之前抽象类和接口对比问题的后续。如果你知道语法差异，你可以很容易回答这个问题，因为它们可以令你做出抉择。当关心升级时，因为不可能在一个发布的接口中添加一个新方法，用抽象类会更好。类似地，如果你的接口中有很多方法，你对它们的实现感到很头疼，考虑提供一个抽象类作为默认实现。这是 Java 集合包中的模式，你可以使用提供默认实现 List 接口的AbstractList。  

### 9. Java 中的抽象方法是什么？
&emsp;&emsp;抽象方法是一个没有方法体的方法。你仅需要声明一个方法，不需要定义它并使用关键字abstract 声明。Java 接口中所有方法的声明默认是 abstract 的。这是抽象方法的例子public void abstract printVersion();现在，为了实现这个方法，你需要继承该抽象类并重载这个方法。  

### 10. Java 抽象类中可以包含 main 方法吗？
&emsp;&emsp;是的，抽象类可以包含 main 方法，它只是一个静态方法，你可以使用 main 方法执行抽象类，但不可以创建任何实例。